#!/usr/bin/env python3
# jamf2snipe - Inventory Import
#
# ABOUT:
#   This program is designed to import inventory information from a
#   JAMFPro into snipe-it using api calls. For more information
#   about both of these products, please visit their respecitive
#   websites:
#       https://jamf.com
#       https://snipeitapp.com
#
# LICENSE:
#   MIT
#
# CONFIGURATION:
#   See README.md

from requests import Response
from requests_cache import install_cache
from functools import lru_cache
import requests
from time import sleep
import configparser
import argparse
import logging
from datetime import datetime, timedelta
from jinja2 import Template

version = "1.0.5"

JAMF_SUBSETS_COMPUTERS = {'general': 'GENERAL',
                          'diskEncryption': 'DISK_ENCRYPTION',
                          'purchasing': 'PURCHASING',
                          'applications': 'APPLICATIONS',
                          'storage': 'STORAGE',
                          'userAndLocation': 'USER_AND_LOCATION',
                          'configurationProfiles': 'CONFIGURATION_PROFILES',
                          'printers': 'PRINTERS',
                          'services': 'SERVICES',
                          'hardware': 'HARDWARE',
                          'localUserAccounts': 'LOCAL_USER_ACCOUNTS',
                          'certificates': 'CERTIFICATES',
                          'attachments': 'ATTACHMENTS',
                          'plugins': 'PLUGINS',
                          'packageReceipts': 'PACKAGE_RECEIPTS',
                          'fonts': 'FONTS',
                          'security': 'SECURITY',
                          'operatingSystem': 'OPERATING_SYSTEM',
                          'licensedSoftware': 'LICENSED_SOFTWARE',
                          'ibeacons': 'IBEACONS',
                          'softwareUpdates': 'SOFTWARE_UPDATES',
                          'extensionAttributes': 'EXTENSION_ATTRIBUTES',
                          'contentCaching': 'CONTENT_CACHING',
                          'groupMemberships': 'GROUP_MEMBERSHIPS'}

JAMF_SUBSETS_MOBILE = {
    'general': 'GENERAL',
    'hardware': 'HARDWARE',
    'userAndLocation': 'USER_AND_LOCATION',
    'purchasing': 'PURCHASING',
    'security': 'SECURITY',
    'applications': 'APPLICATIONS',
    'ebooks': 'EBOOKS',
    'network': 'NETWORK',
    'serviceSubscriptions': 'SERVICE_SUBSCRIPTIONS',
    'certificates': 'CERTIFICATES',
    'profiles': 'PROFILES',
    'userProfiles': 'USER_PROFILES',
    'provisioningProfiles': 'PROVISIONING_PROFILES',
    'sharedUsers': 'SHARED_USERS',
    'extensionAttributes': 'EXTENSION_ATTRIBUTES'
}

# Setup some global variables
JAMF_EXPIRES = datetime.now()
SNIPE_BACKOFF = 0
JAMF_BACKOFF = 0

# Set us up for using runtime arguments by defining them.
runtimeargs = argparse.ArgumentParser()
runtimeargs.add_argument("-v", "--verbose",
                         help="Sets the logging level to INFO and gives you a better idea of what the script is doing.",
                         action="store_true")
runtimeargs.add_argument("--auto_incrementing",
                         help="You can use this if you have auto-incrementing enabled in your snipe instance to "
                              "utilize that instead of adding the Jamf ID for the asset tag.",
                         action="store_true")
runtimeargs.add_argument("--dryrun",
                         help="This checks your CONFIG and tries to contact both the JAMFPro and Snipe-it instances, "
                              "but exits before updating or syncing any assets.",
                         action="store_true")
runtimeargs.add_argument("-d", "--debug", help="Sets logging to include additional DEBUG messages.",
                         action="store_true")
runtimeargs.add_argument("--do_not_update_jamf", help="Do not update Jamf with the asset tags from Snipe.",
                         action="store_true")
runtimeargs.add_argument('--do_not_verify_ssl',
                         help="Skips SSL verification for all requests. Helpful when you use self-signed certificate.",
                         action="store_false")
runtimeargs.add_argument("-f", "--force",
                         help="Updates the Snipe asset with information from Jamf every time, despite what the "
                              "timestamps indicate.",
                         action="store_true")
runtimeargs.add_argument("--version", help="Prints the version and exits.", action="store_true")
user_opts = runtimeargs.add_mutually_exclusive_group()
user_opts.add_argument("-u", "--users",
                       help="Checks out the item to the current user in Jamf if it's not already deployed",
                       action="store_true")
user_opts.add_argument("-uf", "--users_force",
                       help="Checks out the item to the current user in Jamf even if it's already deployed",
                       action="store_true")
type_opts = runtimeargs.add_mutually_exclusive_group()
type_opts.add_argument("-m", "--mobiles", help="Runs against the Jamf mobiles endpoint only.", action="store_true")
type_opts.add_argument("-c", "--computers", help="Runs against the Jamf computers endpoint only.", action="store_true")
USER_ARGS = runtimeargs.parse_args()

if USER_ARGS.version:
    print(version)
    raise SystemExit

# Notify users they're going to get a wall of text in verbose mode.
if USER_ARGS.debug:
    logging.basicConfig(level=logging.DEBUG)
elif USER_ARGS.verbose:
    logging.basicConfig(level=logging.INFO)
else:
    logging.basicConfig(level=logging.WARNING)

# Notify users if we're doing a dry run.
if USER_ARGS.dryrun:
    logging.warning("Dry-run: Starting jamf2snipe with a dry run where no assets will be updated.")

# Find a valid settings.conf file.
logging.info("Searching for a valid settings.conf file.")
CONFIG = configparser.ConfigParser()
logging.debug("Checking for a settings.conf in the local directory first ...")
CONFIG.read("settings.conf")
if 'snipe-it' not in CONFIG:
    logging.debug("No valid CONFIG found in folder. Checking for a settings.conf in /etc/jamf2snipe ...")
    CONFIG.read('/etc/jamf2snipe/settings.conf')
if 'snipe-it' not in CONFIG:
    logging.debug(
        "No valid CONFIG found in /etc/jamf2snipe. Checking for a settings.conf in /opt/jamf2snipe directory ...")
    CONFIG.read("/opt/jamf2snipe/settings.conf")
if 'snipe-it' not in CONFIG:
    logging.error(
        "No valid settings.conf was found. We'll need to quit while you figure out where the settings are at. You can "
        "check the README for valid locations.")
    raise SystemExit("Error: No valid settings.conf - Exiting.")

logging.info("Great, we found a settings file. Let's get started by parsing all of the settings.")

if 'api_mapping' in CONFIG:
    logging.error(
        "The api_mapping section is deprecated. Please use computers-api-mapping and mobile_devices-api-mapping "
        "instead.")
    raise SystemExit("Error: Deprecated api_mapping section found in settings.conf - Exiting.")

if (USER_ARGS.users or USER_ARGS.users_force) and 'user-mapping' not in CONFIG:
    logging.error("You've chosen to check out assets to users in some capacity using a cmdline switch,"
                  " but not specified how you want to search Snipe IT for the users from Jamf.\n"
                  "Make sure you have a 'user-mapping' section in your settings.conf file.")
    raise SystemExit("Error: Missing user-mapping section in settings.conf - Exiting.")

# Get the variables using a try block, so we can raise a KeyError if something goes wrong.
try:
    # Set some Variables from the settings.conf:
    # This is the address, cname, or FQDN for your JamfPro instance.
    logging.info("Checking the Jamf Pro Base url...")
    logging.debug(f"The configured Jamf Pro base url is: {CONFIG['jamf']['url']}")

    logging.info("Checking the JAMF username...")
    logging.debug(f"The user you provided for Jamf is: {CONFIG['jamf']['username']}")

    logging.info("Checking the JAMF password...")
    # DEV: Only enable this if you want to see the password in the log.
    # logging.debug(f"The password you provided for Jamf is: {CONFIG['jamf']['password']}")

    logging.info("Checking the base URL for Snipe-IT...")
    logging.debug(f"The configured Snipe-IT base url is: {CONFIG['snipe-it']['url']}")

    logging.info("Checking the Snipe-IT API key...")
    # DEV: Only enable this if you want to see the API key in the log.
    # logging.debug(f"The API key you provided for Snipe-IT is: {CONFIG['snipe-it']['apikey']}")

    logging.info("Checking the default status for Snipe-IT assets...")
    logging.debug(f"The default status we'll be setting updated assets to is: "
                  f"{CONFIG['snipe-it']['default_status_id']}")

    logging.info("Checking the Snipe ID for Apple...")
    # TODO: Use plain text and query this from API
    logging.debug(
        f"The configured manufacturer ID for Apple computers in snipe is: {CONFIG['snipe-it']['manufacturer_id']}")

    logging.info("Checking the Computers API mapping...")
    logging.debug(f"The configured Computers API mapping is: {CONFIG['computers-api-mapping']}")

    logging.info("Checking the Mobile Devices API mapping...")
    logging.debug(f"The configured Mobile Devices API mapping is: {CONFIG['mobile_devices-api-mapping']}")
except KeyError:
    logging.error(
        "Some of the required settings from the settings.conf were missing or invalid. Re-run jamf2snipe with the "
        "--verbose or --debug flag to get more details on which setting is missing or misconfigured.")
    raise SystemExit("Error: Missing or invalid settings in settings.conf - Exiting.")

if not CONFIG['snipe-it']['manufacturer_id'].isnumeric():
    raise SystemExit(
        "Error: The manufacturer_id in settings.conf is not a number. Please check your settings.conf file and try "
        "again.")

if not CONFIG['snipe-it']['default_status_id'].isnumeric():
    raise SystemExit(
        "Error: The default_status_id in settings.conf is not a number. "
        "Please check your settings.conf file and try again.")

# Check the CONFIG file for correct headers

if CONFIG['snipe-it']['url'].endswith("/"):
    raise SystemExit("Error: You have a trailing forward slash in the snipe url. Please remove it.")

if CONFIG['jamf']['url'].endswith("/"):
    raise SystemExit("Error: You have a trailing forward slash in the jamf url. Please remove it.")

# Headers for the API call.
logging.info("Creating the headers we'll need for API calls")
JAMF_HEADERS = {'Accept': 'application/json', 'Content-Type': 'application/json'}
SNIPE_HEADERS = {'Authorization': f"Bearer {CONFIG['snipe-it']['apikey']}",
                 'Accept': 'application/json',
                 'Content-Type': 'application/json'}

# Report if we're verifying SSL or not.
logging.info(f"SSL Verification is set to: {USER_ARGS.do_not_verify_ssl}")

# DEV use only, do not leave API keys in logs.
# logging.debug(f"Request headers for JAMF will be: {JAMF_HEADERS}")
# logging.debug(f"Request headers for Snipe will be: {SNIPE_HEADERS}")

# Enable caching
if CONFIG['cache'].get('expire_after', None):
    cache_time = CONFIG['cache'].getint('expire_after')
    cache_location = CONFIG['cache'].get('location', '/tmp/jamf2snipe.cache')
    logging.info(f"Enabling caching for API calls for {cache_time} seconds.")
    install_cache(cache_location, backend='sqlite', expire_after=cache_time)


# Use Basic Auth to request a Jamf Token.
def request_jamf_token():
    # Tokens expire after 30 minutes (new API)
    global CONFIG, JAMF_HEADERS, JAMF_EXPIRES

    api_url = f"{CONFIG['jamf']['url']}/api/v1/auth/token"

    # We assume it may take ~15 seconds to get a token
    if ('Authorization' in JAMF_HEADERS and JAMF_HEADERS['Authorization'] and
            JAMF_EXPIRES > datetime.now() + timedelta(seconds=15)):
        api_url = f"{CONFIG['jamf']['url']}/api/v1/auth/keep-alive"

    # No hook for this api call.
    logging.debug(f'Calling for a token against: {api_url}')

    response = api_call(api_url,
                        auth=(CONFIG['jamf']['username'], CONFIG['jamf']['password']),
                        method="POST",
                        headers=JAMF_HEADERS)

    response_json = response.json()
    # No hook for this API call.
    if response.status_code == 200:
        logging.debug("Got back a valid 200 response code.")
        # DEV: Only enable this if you want to see the token in the log.
        # logging.debug(jsonresponse)
        try:
            # Parse this 2022-01-24T21:35:20.373Z or  2023-10-12T00:09:38Z
            if "." in response_json['expires']:
                JAMF_EXPIRES = datetime.strptime(response_json['expires'], "%Y-%m-%dT%H:%M:%S.%fZ")
            else:
                JAMF_EXPIRES = datetime.strptime(response_json['expires'], "%Y-%m-%dT%H:%M:%SZ")
        except ValueError:
            logging.error(f"Timestamp in {response_json} is invalid - exiting")
            raise SystemExit("Unable to grok Jamf Timestamp - Exiting")

        logging.debug(f"Token expires at {JAMF_EXPIRES}")

        # The headers are also global, because they get used elsewhere.
        logging.info("Setting new jamf headers with bearer token")
        JAMF_HEADERS['Authorization'] = f'Bearer {response_json["token"]}'
    else:
        logging.error("Could not obtain a token for use, please check your username and password.")
        raise SystemExit("Unable to obtain Jamf Token")


# Function to make the API call for all JAMF devices
# Returns a list of all computers in JAMF with inventory details
# Pass filter_rsql in rsql format - e.g. "general.assetTag==123456"
@lru_cache(maxsize=64)
def get_jamf_computers(filter_rsql=None):
    global CONFIG
    # Sections the user wants to retrieve, we require general and hardware for getting serial/asset numbers
    sections = {"GENERAL", "HARDWARE"}
    for mapping in CONFIG['computers-api-mapping'].values():
        # Get index in JAMF_SUBSETS_COMPUTERS
        root = mapping.split(" ")[0]
        if root in JAMF_SUBSETS_COMPUTERS:
            sections.add(JAMF_SUBSETS_COMPUTERS[root])

    # Get the user mapping
    if USER_ARGS.users or USER_ARGS.users_force:
        key = CONFIG['user-mapping']['computer_api_field'].split(" ")[0]
        sections.add(JAMF_SUBSETS_COMPUTERS[key])

    search_query = "?section=" + "&section=".join(sections)

    if filter_rsql:
        search_query += f"&filter={filter_rsql}"

    logging.info("Fetching JAMF computers...")
    return get_jamf_paginated_objects(f"/api/v1/computers-inventory{search_query}")


# Function to make an API call with pagination, returning all objects
def get_jamf_paginated_objects(api, page=0):
    # Function arguments should not be mutable
    page_size = 500

    page_add = f"&page={page}&page-size={page_size}"
    response = jamf_api_call(f"{api}{page_add}", method="GET")

    if "results" not in response or not response['results'] or "totalCount" not in response:
        logging.info("Received an invalid response from Jamf, exiting")
        logging.debug(response)
        raise SystemExit("Invalid response from Jamf")

    current = response['results']
    logging.debug(f"Received: {len(current)} objects")

    page += 1
    if (page_size * page) < response['totalCount']:
        current.extend(get_jamf_paginated_objects(api, page))

    return current


# Function to make the API call for all JAMF mobile devices
@lru_cache(maxsize=64)
def get_jamf_mobiles(filter_rsql=None):
    global USER_ARGS
    # Sections the user wants to retrieve, we require general and hardware for getting serial/asset numbers
    sections = {"GENERAL", "HARDWARE"}

    for mapping in CONFIG['mobile_devices-api-mapping'].values():
        # Get index in JAMF_SUBSETS_MOBILE
        root = mapping.split(" ")[0]
        if root in JAMF_SUBSETS_MOBILE:
            sections.add(JAMF_SUBSETS_MOBILE[root])

    # Get the user mapping
    if USER_ARGS.users or USER_ARGS.users_force:
        key = CONFIG['user-mapping']['mobile_api_field'].split(" ")[0]
        sections.add(JAMF_SUBSETS_COMPUTERS[key])

    search_query = "?section=" + "&section=".join(sections)

    if filter_rsql:
        search_query += f"&filter={filter_rsql}"

    logging.info("Fetching JAMF computers...")
    return get_jamf_paginated_objects(f"/api/v2/mobile-devices/detail{search_query}")


# Function to update the asset tag of mobile devices in JAMF with a number passed from Snipe.
def update_jamf_mobiledevice_asset_tag(jamf_id, asset_tag):
    # /api/v1/computers-inventory-detail/5
    if USER_ARGS.do_not_update_jamf:
        logging.warning("Not updating JAMF as requested")
        return None

    return jamf_api_call(f"/api/v2/mobile-devices/{jamf_id}",
                         payload={"assetTag": str(asset_tag)},
                         method="PATCH")


def update_jamf_computer_asset_tag(jamf_id, asset_tag):
    if USER_ARGS.do_not_update_jamf:
        logging.warning("Not updating JAMF as requested")
        return None

    # /api/v1/computers-inventory-detail/5
    return jamf_api_call(f"/api/v1/computers-inventory-detail/{jamf_id}",
                         payload={"general": {"assetTag": str(asset_tag)}},
                         method="PATCH")


# Function to find snipe assets by serial number.
def search_snipe_asset(serial) -> list:
    global CONFIG, USER_ARGS
    response = snipe_api_call(f"hardware/byserial/{serial}")

    if "total" not in response or response['total'] == 0:
        logging.info(f"No asset found for {serial}")
        logging.debug(response)
        return []

    return response['rows']


# Helper function to call an API
def api_call(api_url, json=None, method="GET", headers=None, auth=None) -> Response:
    logging.debug(f"Calling {api_url} with method {method} and payload {json}")

    if method == "GET":
        response = requests.get(api_url, headers=headers, json=json, verify=USER_ARGS.do_not_verify_ssl)
    elif method == "POST":
        response = requests.post(api_url, auth=auth, headers=headers, json=json, verify=USER_ARGS.do_not_verify_ssl)
    elif method == "PATCH":
        response = requests.patch(api_url, headers=headers, json=json, verify=USER_ARGS.do_not_verify_ssl)
    else:
        logging.error(f"Unknown method {method}")
        raise SystemExit("Unknown method")

    return response


def snipe_api_call(endpoint, payload=None, method="GET"):
    global CONFIG, SNIPE_HEADERS, SNIPE_BACKOFF

    api_url = f"{CONFIG['snipe-it']['url']}/api/v1/{endpoint}"

    response = api_call(api_url, payload, method, SNIPE_HEADERS)

    if response.status_code == 200:
        if SNIPE_BACKOFF:
            SNIPE_BACKOFF -= 1
        # DEV: This is a lot of output
        # logging.debug(f"Got a valid response from Snipe-IT: {response.text}")
        return response.json()

    if response.status_code == 429:
        SNIPE_BACKOFF += 1
        backoff = SNIPE_BACKOFF * 30
        logging.warning(f'Snipe-IT ratelimit exceeded: pausing {backoff}s')
        sleep(backoff)
        logging.info("Finished waiting. Retrying lookup...")
        return snipe_api_call(endpoint, payload, method)

    logging.error(f"Snipe-IT responded with error code:{response.text}")
    logging.debug(f"{response.status_code} - {response.content}")
    raise SystemExit("Snipe-IT API call failed")


def jamf_api_call(endpoint, payload=None, method="GET"):
    global CONFIG, JAMF_HEADERS, JAMF_BACKOFF, JAMF_EXPIRES
    api_url = f"{CONFIG['jamf']['url']}{endpoint}"

    if JAMF_EXPIRES < datetime.now() + timedelta(minutes=2):
        logging.info("Token expiring soon or already expired, requesting new token")
        request_jamf_token()

    response = api_call(api_url, payload, method, JAMF_HEADERS)

    if response.status_code == 200:
        return response.json()

    if response.status_code == 429:
        JAMF_BACKOFF += 1
        backoff = JAMF_BACKOFF * 30
        logging.warning(f'JAMF Pro Ratelimit exceeded: pausing {backoff}s')
        sleep(backoff)
        logging.info("Finished waiting. Retrying lookup...")
        return jamf_api_call(endpoint, payload, method)

    logging.error(f"JAMF responded with error code:{response.text}")
    logging.debug(f"{response.status_code} - {response.content}")
    raise SystemExit("JAMF API call failed")


# Function to get all the asset models (and cache them)
@lru_cache(maxsize=None)
def get_snipe_models(page=0):
    page_size = 500
    limits = {
        'limit': page_size,
        'offset': page * page_size
    }
    models = {}
    response = snipe_api_call("models", payload=limits)

    # This happens if there is an error
    if "total" not in response:
        logging.error("Fetching models failed, enable debug to see response")
        raise SystemExit("Necessary Snipe-IT API call failed")

    # Quickly end if there are no rows
    if "rows" not in response:
        return models

    # Add the models to the dictionary
    for row in response['rows']:
        models[row['model_number']] = row['id']

    # If we haven't gotten all the models, get more
    if response['total'] >= limits['offset']:
        logging.debug(f"Fetching more models, currently at: {limits['offset']}/{response['total']}")
        models.update(get_snipe_models(page + 1))

    return models


# Function to search snipe for a user
@lru_cache(maxsize=None)
def get_snipe_user_id(username):
    if not username:
        return None
    username = username.lower()
    response = snipe_api_call("users", method="GET", payload={'username': username})
    if 'total' not in response or response['total'] == 0:
        return None

    if response['total'] > 1:
        logging.warning(f"Found {response['total']} users with username {username}, returning none")
        return None

    return response['rows'][0]['id']


# Function that creates a new Snipe Model - not an asset - with a JSON payload
def create_snipe_model(model):
    response = snipe_api_call("models", payload=model, method="POST")

    if "payload" not in response or not response['payload']:
        logging.error(f'Unable to create model: {model}. Received {response}')
        return None

    return response['payload']['id']


# Function to create a new asset by passing array
def create_snipe_asset(asset):
    logging.info(f"Creating asset in Snipe-IT")
    response = snipe_api_call("hardware", payload=asset, method="POST")
    if "payload" not in response or not response['payload']:
        logging.error(f'Unable to create asset: {asset}. Received {response}')
        raise SystemExit("Unable to create asset(s)")

    return response['payload']


# Function that updates a snipe asset with a JSON payload
def update_snipe_asset(snipe_id, payload):
    logging.debug(f'The payload for the snipe update is: {payload}')
    response = snipe_api_call(f"hardware/{snipe_id}", payload=payload, method="PATCH")

    if "payload" not in response or not response['payload']:
        logging.error(f'Unable to update asset: {snipe_id}. Received {response}')
        return None

    return response['payload']


# Function that checks in an asset in snipe
def checkin_snipe_asset(asset_id, asset):
    if not asset['available_actions']['checkin']:
        logging.error(f"Asset {asset['name']} is not available for checkin")
        return False

    note = {
        'note': 'checked in by script from Jamf'
    }

    response = snipe_api_call(f"hardware/{asset_id}/checkin", payload=note, method="POST")

    if "payload" not in response or not response['payload']:
        logging.error(f'Unable to checkin asset: {asset_id}. Received {response}')
        return False

    return True


# Function that checks out an asset in snipe
def checkout_snipe_asset(username, asset):
    global USER_ARGS

    if (not USER_ARGS.users and not USER_ARGS.users_force) or not username:
        return False

    logging.info(f"Asset {asset['name']} is being checked out to {username}")
    logging.debug(asset)

    user_id = get_snipe_user_id(username)

    if not user_id:
        logging.error(f"Unable to checkout asset: {asset['name']} to user {username}, user does not exist")
        return False

    if 'assigned_to' in asset and asset['assigned_to']:
        # Sometimes my JAMF API returns an int, sometimes a dict. This makes it consistent.
        if isinstance(asset['assigned_to'], int):
            temp_user_id = asset['assigned_to']
            asset['assigned_to'] = {}
            asset['assigned_to']['id'] = temp_user_id

        if asset['assigned_to']['id'] == user_id:
            logging.info(f"Asset {asset['id']} is already checked out to {username}")
            return True

        logging.info(f"Asset {asset['id']} is already checked out to UID: {asset['assigned_to']['id']}")

        if not USER_ARGS.users_force:
            return False

        if not checkin_snipe_asset(asset['id'], asset):
            return False

    payload = {
        'checkout_to_type': 'user',
        'assigned_user': user_id,
        'note': 'Assignment made automatically, via script from Jamf.'
    }

    response = snipe_api_call(f"hardware/{asset['id']}/checkout", payload=payload, method="POST")

    if "payload" not in response or not response['payload']:
        logging.error("Asset checkout failed, enable debug to see more information")
        logging.debug(response)
        return False

    return True


# Function to recursively get keys from a dictionary
def get_config_value(config_key, data, invalid_values=None):
    logging.debug(f"Getting config value for {config_key}")
    logging.debug(f"Data: {data}")
    split_key = config_key.split("|", 1)
    search_keys = split_key[0].strip().split(" ")
    j2_str = None
    if len(split_key) > 1:
        j2_str = split_key[1].strip()
        logging.debug(f"Jinja2 template: {j2_str}")

    value = data
    for key in search_keys:
        try:
            # Try to convert to int, settings file returns strings,
            # but if we want to traverse a list we need an int
            key = int(key)
        except ValueError:
            logging.debug(f"{key} is not an integer")
        try:
            value = value[key]
        except (KeyError, IndexError, TypeError):
            # JAMF is not consistent with return types
            logging.info(f"{key} does not exist or is empty")
            logging.debug(f"Key value: {value}")
            value = None
            break

    if invalid_values and value in invalid_values:
        value = None

    if j2_str:
        template = Template(j2_str)
        value = template.render(var=value, data=data)

    logging.debug(f"Got value {value} for {config_key}")
    return value


def clean_tag(param):
    # Remove illegal values
    if param.lower() in ["unknown", "not available", "0"]:
        return None

    return param


def main():
    global USER_ARGS
    # Do some tests to see if the hosts are up. Don't use hooks for these as we don't have tokens yet.
    logging.info("Running tests to see if hosts are up.")

    # Get a list of known models from Snipe
    logging.info("Getting a list of computer models that snipe knows about.")
    modelnumbers = get_snipe_models()
    logging.info(f"Our list of models has {len(modelnumbers)} entries.")
    logging.debug(f"Model list: {modelnumbers}")

    # Get a list of computers from JAMF
    mobile_filter = CONFIG['jamf'].get("mobile_devices-filter", None)
    computer_filter = CONFIG['jamf'].get("computer-filter", None)
    if USER_ARGS.computers:
        complete_list = get_jamf_computers(computer_filter)
    elif USER_ARGS.mobiles:
        complete_list = get_jamf_mobiles(mobile_filter)
    else:
        complete_list = get_jamf_computers(computer_filter)
        complete_list.extend(get_jamf_mobiles(mobile_filter))

    total = len(complete_list)

    # Make sure we have a good list.
    logging.info(f'Received a list of JAMF assets that had {total} entries.')

    # After this point we start editing data, so quit if this is a dryrun
    if USER_ARGS.dryrun:
        raise SystemExit("Dryrun: Complete.")

    # From this point on, we're editing data.
    logging.info('Starting to Update Inventory')

    for jamf_asset in complete_list:
        # We can differentiate between a computer and a mobile device by the presence of a mobileDeviceId
        logging.debug(f"Processing JAMF asset: {jamf_asset}")
        custom_fieldset_id = None
        if "mobileDeviceId" in jamf_asset:
            jamf_id = jamf_asset['mobileDeviceId']
            category_id = CONFIG['snipe-it']['mobile_model_category_id']
            api_mapping = CONFIG['mobile_devices-api-mapping']
            jamf_username = get_config_value(CONFIG['user-mapping']['mobile_api_field'],
                                             jamf_asset,
                                             CONFIG['user-mapping'].get('invalid_users', "").split(" "))
            if 'computer_custom_fieldset_id' in CONFIG['snipe-it']:
                custom_fieldset_id = int(CONFIG['snipe-it']['computer_custom_fieldset_id'])
            asset_tag_prefix = CONFIG['snipe-it'].get('mobile_asset_tag_prefix', 'jamfid-m-')
            if ('lastInventoryUpdateDate' not in jamf_asset['general'] or
                    not jamf_asset['general']['lastInventoryUpdateDate']):
                logging.warning(f"Asset {jamf_asset['id']} has no last inventory update date")
                jamf_update_time = datetime.fromtimestamp(0)
            elif "." in jamf_asset['general']['lastInventoryUpdateDate']:
                jamf_update_time = datetime.strptime(jamf_asset['general']['lastInventoryUpdateDate'],
                                                     "%Y-%m-%dT%H:%M:%S.%fZ")
            else:
                jamf_update_time = datetime.strptime(jamf_asset['general']['lastInventoryUpdateDate'],
                                                     "%Y-%m-%dT%H:%M:%SZ")
        else:
            jamf_id = jamf_asset['id']
            category_id = CONFIG['snipe-it']['computer_model_category_id']
            api_mapping = CONFIG['computers-api-mapping']
            jamf_username = get_config_value(CONFIG['user-mapping']['mobile_api_field'],
                                             jamf_asset,
                                             CONFIG['user-mapping'].get('invalid_users', "").split(" "))
            if 'computer_custom_fieldset_id' in CONFIG['snipe-it']:
                custom_fieldset_id = int(CONFIG['snipe-it']['computer_custom_fieldset_id'])
            asset_tag_prefix = CONFIG['snipe-it'].get('computer_asset_tag_prefix', 'jamfid-')
            if 'reportDate' not in jamf_asset['general'] or not jamf_asset['general']['reportDate']:
                logging.warning(f"Asset {jamf_asset['id']} has no report date")
                jamf_update_time = datetime.fromtimestamp(0)
            elif "." in jamf_asset['general']['reportDate']:
                jamf_update_time = datetime.strptime(jamf_asset['general']['reportDate'], "%Y-%m-%dT%H:%M:%S.%fZ")
            else:
                jamf_update_time = datetime.strptime(jamf_asset['general']['reportDate'], "%Y-%m-%dT%H:%M:%SZ")

        logging.debug(f"Processing JAMF ID: {jamf_id}")

        model_jamf_id = jamf_asset['hardware']['modelIdentifier']
        model_jamf_name = jamf_asset['hardware']['model']
        serial_number = get_config_value(api_mapping['serial_number'], jamf_asset)

        if not clean_tag(serial_number):
            logging.warning(f"Asset {jamf_asset['id']} has no (valid) serial number, skipping")
            continue

        if model_jamf_id and model_jamf_id not in modelnumbers:
            logging.warning(f"Asset {jamf_asset['id']} has an unknown model {model_jamf_id}")
            model = {
                "manufacturer_id": CONFIG['snipe-it']['manufacturer_id'],
                "name": model_jamf_name,
                "model_number": model_jamf_id,
                "category_id": category_id
            }
            if custom_fieldset_id:
                model['fieldset_id'] = int(CONFIG['snipe-it']['computer_custom_fieldset_id'])

            modelnumbers[model_jamf_id] = create_snipe_model(model)

        asset = {
            'serial': serial_number,
            'model_id': modelnumbers[model_jamf_id]
        }

        if not USER_ARGS.auto_incrementing:
            logging.debug("Auto incrementing is disabled")
            asset['asset_tag'] = jamf_asset['general']['assetTag']

            if not asset['asset_tag']:
                asset['asset_tag'] = f"{asset_tag_prefix}{jamf_id}"

        # Get the serial from snipe
        snipe_asset = search_snipe_asset(serial_number)

        if len(snipe_asset) > 1:
            logging.warning(f"Found {len(snipe_asset)} assets with serial {serial_number}, skipping")
            continue

        for api_key in api_mapping:
            value = get_config_value(api_mapping[api_key], jamf_asset)
            if value:
                asset[api_key] = value

        if not snipe_asset:
            # Create a new asset
            logging.info(f"Creating a new asset in snipe for JAMF ID: {jamf_id}")
            asset['status_id'] = CONFIG['snipe-it']['default_status_id']
            snipe_asset = [create_snipe_asset(asset)]
            # If new asset, then snipe update time = jamf update time
            snipe_update_time = jamf_update_time
        else:
            logging.info(f"Asset exists in snipe for JAMF ID: {jamf_id}")
            logging.debug(snipe_asset)
            # Snipe formats 2023-10-11 11:43:34
            snipe_update_time = datetime.strptime(snipe_asset[0]['updated_at']['datetime'], "%Y-%m-%d %H:%M:%S")

        # Check if we need updating
        if snipe_asset and (USER_ARGS.force or snipe_update_time < jamf_update_time):
            # Update the asset
            logging.info(f"Updating asset in snipe for JAMF ID: {jamf_id}")

            # Clean up primary keys
            for asset_key in snipe_asset[0].keys():
                if asset_key in asset:
                    logging.debug(f"Updating {asset_key} from {snipe_asset[0][asset_key]} to {asset[asset_key]}")
                    if snipe_asset[0][asset_key] == asset[asset_key]:
                        del asset[asset_key]

            if 'model_id' in asset and 'model' in snipe_asset[0]:
                if snipe_asset[0]['model']['id'] == asset['model_id']:
                    del asset['model_id']

            # Clean up custom fields
            for custom_field in snipe_asset[0]['custom_fields'].values():
                logging.debug(custom_field)
                snipe_field = custom_field['field']
                if snipe_field in asset.keys():
                    logging.debug(f"Updating {custom_field} from "
                                  f"{custom_field['value']} "
                                  f"to {asset[snipe_field]}")
                    if str(custom_field['value']) == str(asset[snipe_field]):
                        del asset[snipe_field]

            if asset:
                asset = update_snipe_asset(snipe_asset[0]['id'], asset)

        # Checking out
        # Username could be in assigned_to
        checkout_snipe_asset(jamf_username, snipe_asset[0])

        if 'asset_tag' in snipe_asset and str(snipe_asset[0]['asset_tag']) != str(jamf_asset['general']['assetTag']):
            logging.info(f"Updating JAMF asset tag from {jamf_asset['general']['assetTag']} to {asset['asset_tag']}")
            if "mobileDeviceId" in jamf_asset:
                update_jamf_mobiledevice_asset_tag(jamf_asset['mobileDeviceId'], asset['asset_tag'])
            else:
                update_jamf_computer_asset_tag(jamf_asset['id'], asset['asset_tag'])


if __name__ == "__main__":
    main()
