#!/usr/bin/env python3
# jamf2snipe - Inventory Import
#
# ABOUT:
#   This program is designed to import inventory information from a
#   JAMFPro into snipe-it using api calls. For more information
#   about both of these products, please visit their respecitive
#   websites:
#       https://jamf.com
#       https://snipeitapp.com
#
# LICENSE:
#   MIT
#
# CONFIGURATION:
#   See README.md
from __future__ import annotations

import html
import re

from requests import Response
from requests_cache import install_cache
from functools import lru_cache
import requests
from time import sleep
import configparser
import argparse
import logging
from datetime import datetime, timedelta, date
from jinja2 import Template

version = "1.0.5"

JAMF_SUBSETS_COMPUTERS = {'general': 'GENERAL',
                          'diskEncryption': 'DISK_ENCRYPTION',
                          'purchasing': 'PURCHASING',
                          'applications': 'APPLICATIONS',
                          'storage': 'STORAGE',
                          'userAndLocation': 'USER_AND_LOCATION',
                          'configurationProfiles': 'CONFIGURATION_PROFILES',
                          'printers': 'PRINTERS',
                          'services': 'SERVICES',
                          'hardware': 'HARDWARE',
                          'localUserAccounts': 'LOCAL_USER_ACCOUNTS',
                          'certificates': 'CERTIFICATES',
                          'attachments': 'ATTACHMENTS',
                          'plugins': 'PLUGINS',
                          'packageReceipts': 'PACKAGE_RECEIPTS',
                          'fonts': 'FONTS',
                          'security': 'SECURITY',
                          'operatingSystem': 'OPERATING_SYSTEM',
                          'licensedSoftware': 'LICENSED_SOFTWARE',
                          'ibeacons': 'IBEACONS',
                          'softwareUpdates': 'SOFTWARE_UPDATES',
                          'extensionAttributes': 'EXTENSION_ATTRIBUTES',
                          'contentCaching': 'CONTENT_CACHING',
                          'groupMemberships': 'GROUP_MEMBERSHIPS'}

JAMF_SUBSETS_MOBILE = {
    'general': 'GENERAL',
    'hardware': 'HARDWARE',
    'userAndLocation': 'USER_AND_LOCATION',
    'purchasing': 'PURCHASING',
    'security': 'SECURITY',
    'applications': 'APPLICATIONS',
    'ebooks': 'EBOOKS',
    'network': 'NETWORK',
    'serviceSubscriptions': 'SERVICE_SUBSCRIPTIONS',
    'certificates': 'CERTIFICATES',
    'profiles': 'PROFILES',
    'userProfiles': 'USER_PROFILES',
    'provisioningProfiles': 'PROVISIONING_PROFILES',
    'sharedUsers': 'SHARED_USERS',
    'extensionAttributes': 'EXTENSION_ATTRIBUTES'
}

# Setup some global variables
JAMF_EXPIRES = datetime.now()
SNIPE_BACKOFF = 0
JAMF_BACKOFF = 0

# Set us up for using runtime arguments by defining them.
runtimeargs = argparse.ArgumentParser()
runtimeargs.add_argument("-v", "--verbose",
                         help="Sets the logging level to INFO and gives you a better idea of what the script is doing.",
                         action="store_true")
runtimeargs.add_argument("--auto_incrementing",
                         help="You can use this if you have auto-incrementing enabled in your snipe instance to "
                              "utilize that instead of adding the Jamf ID for the asset tag.",
                         action="store_true")
runtimeargs.add_argument("--dryrun",
                         help="This checks your CONFIG and tries to contact both the JAMFPro and Snipe-it instances, "
                              "but exits before updating or syncing any assets.",
                         action="store_true")
runtimeargs.add_argument("-d", "--debug", help="Sets logging to include additional DEBUG messages.",
                         action="store_true")
runtimeargs.add_argument("--do_not_update_jamf", help="Do not update Jamf with the asset tags from Snipe.",
                         action="store_true")
runtimeargs.add_argument('--do_not_verify_ssl',
                         help="Skips SSL verification for all requests. Helpful when you use self-signed certificate.",
                         action="store_false")
runtimeargs.add_argument("-f", "--force",
                         help="Updates the Snipe asset with information from Jamf every time, despite what the "
                              "timestamps indicate.",
                         action="store_true")
runtimeargs.add_argument("--version", help="Prints the version and exits.", action="store_true")
user_opts = runtimeargs.add_mutually_exclusive_group()
user_opts.add_argument("-u", "--users",
                       help="Checks out the item to the current user in Jamf if it's not already deployed",
                       action="store_true")
user_opts.add_argument("-uf", "--users_force",
                       help="Checks out the item to the current user in Jamf even if it's already deployed",
                       action="store_true")
type_opts = runtimeargs.add_mutually_exclusive_group()
type_opts.add_argument("-m", "--mobiles", help="Runs against the Jamf mobiles endpoint only.", action="store_true")
type_opts.add_argument("-c", "--computers", help="Runs against the Jamf computers endpoint only.", action="store_true")
USER_ARGS = runtimeargs.parse_args()

if USER_ARGS.version:
    print(version)
    raise SystemExit

# Notify users they're going to get a wall of text in verbose mode.
if USER_ARGS.debug:
    logging.basicConfig(level=logging.DEBUG)
elif USER_ARGS.verbose:
    logging.basicConfig(level=logging.INFO)
else:
    logging.basicConfig(level=logging.WARNING)

# Notify users if we're doing a dry run.
if USER_ARGS.dryrun:
    logging.warning("Dry-run: Starting jamf2snipe with a dry run where no assets will be updated.")

# Find a valid settings.conf file.
logging.info("Searching for a valid settings.conf file.")
CONFIG = configparser.ConfigParser()
logging.debug("Checking for a settings.conf in the local directory first ...")
CONFIG.read("settings.conf")
if 'snipe-it' not in CONFIG:
    logging.debug("No valid CONFIG found in folder. Checking for a settings.conf in /etc/jamf2snipe ...")
    CONFIG.read('/etc/jamf2snipe/settings.conf')
if 'snipe-it' not in CONFIG:
    logging.debug(
        "No valid CONFIG found in /etc/jamf2snipe. Checking for a settings.conf in /opt/jamf2snipe directory ...")
    CONFIG.read("/opt/jamf2snipe/settings.conf")
if 'snipe-it' not in CONFIG:
    logging.error(
        "No valid settings.conf was found. We'll need to quit while you figure out where the settings are at. You can "
        "check the README for valid locations.")
    raise SystemExit("Error: No valid settings.conf - Exiting.")

logging.info("Great, we found a settings file. Let's get started by parsing all of the settings.")

if 'api_mapping' in CONFIG:
    logging.error(
        "The api_mapping section is deprecated. Please use computers-api-mapping and mobile_devices-api-mapping "
        "instead.")
    raise SystemExit("Error: Deprecated api_mapping section found in settings.conf - Exiting.")

if (USER_ARGS.users or USER_ARGS.users_force) and 'user-mapping' not in CONFIG:
    logging.error("You've chosen to check out assets to users in some capacity using a cmdline switch,"
                  " but not specified how you want to search Snipe IT for the users from Jamf.\n"
                  "Make sure you have a 'user-mapping' section in your settings.conf file.")
    raise SystemExit("Error: Missing user-mapping section in settings.conf - Exiting.")

# Get the variables using a try block, so we can raise a KeyError if something goes wrong.
try:
    # Set some Variables from the settings.conf:
    # This is the address, cname, or FQDN for your JamfPro instance.
    logging.info("Checking the Jamf Pro Base url...")
    logging.debug(f"The configured Jamf Pro base url is: {CONFIG['jamf']['url']}")

    logging.info("Checking the JAMF username...")
    logging.debug(f"The user you provided for Jamf is: {CONFIG['jamf']['username']}")

    logging.info("Checking the JAMF password...")
    # DEV: Only enable this if you want to see the password in the log.
    # logging.debug(f"The password you provided for Jamf is: {CONFIG['jamf']['password']}")

    logging.info("Checking the base URL for Snipe-IT...")
    logging.debug(f"The configured Snipe-IT base url is: {CONFIG['snipe-it']['url']}")

    logging.info("Checking the Snipe-IT API key...")
    # DEV: Only enable this if you want to see the API key in the log.
    # logging.debug(f"The API key you provided for Snipe-IT is: {CONFIG['snipe-it']['apikey']}")

    logging.info("Checking the default status for Snipe-IT assets...")
    logging.debug(f"The default status we'll be setting updated assets to is: "
                  f"{CONFIG['snipe-it']['default_status_id']}")

    logging.info("Checking the Snipe ID for Apple...")
    # TODO: Use plain text and query this from API
    logging.debug(
        f"The configured manufacturer ID for Apple computers in snipe is: {CONFIG['snipe-it']['manufacturer_id']}")

    logging.info("Checking the Computers API mapping...")
    logging.debug(f"The configured Computers API mapping is: {CONFIG['computers-api-mapping']}")

    logging.info("Checking the Mobile Devices API mapping...")
    logging.debug(f"The configured Mobile Devices API mapping is: {CONFIG['mobile_devices-api-mapping']}")
except KeyError:
    logging.error(
        "Some of the required settings from the settings.conf were missing or invalid. Re-run jamf2snipe with the "
        "--verbose or --debug flag to get more details on which setting is missing or misconfigured.")
    raise SystemExit("Error: Missing or invalid settings in settings.conf - Exiting.")

if not CONFIG['snipe-it']['manufacturer_id'].isnumeric():
    raise SystemExit(
        "Error: The manufacturer_id in settings.conf is not a number. Please check your settings.conf file and try "
        "again.")

if not CONFIG['snipe-it']['default_status_id'].isnumeric():
    raise SystemExit(
        "Error: The default_status_id in settings.conf is not a number. "
        "Please check your settings.conf file and try again.")

# Check the CONFIG file for correct headers

if CONFIG['snipe-it']['url'].endswith("/"):
    raise SystemExit("Error: You have a trailing forward slash in the snipe url. Please remove it.")

if CONFIG['jamf']['url'].endswith("/"):
    raise SystemExit("Error: You have a trailing forward slash in the jamf url. Please remove it.")

# Headers for the API call.
logging.info("Creating the headers we'll need for API calls")
JAMF_HEADERS = {'Accept': 'application/json', 'Content-Type': 'application/json'}
SNIPE_HEADERS = {'Authorization': f"Bearer {CONFIG['snipe-it']['apikey']}",
                 'Accept': 'application/json',
                 'Content-Type': 'application/json'}

# Report if we're verifying SSL or not.
logging.info(f"SSL Verification is set to: {USER_ARGS.do_not_verify_ssl}")

# DEV use only, do not leave API keys in logs.
# logging.debug(f"Request headers for JAMF will be: {JAMF_HEADERS}")
# logging.debug(f"Request headers for Snipe will be: {SNIPE_HEADERS}")

# Enable caching
if CONFIG['cache'].get('expire_after', None):
    cache_time = CONFIG['cache'].getint('expire_after')
    cache_location = CONFIG['cache'].get('location', '/tmp/jamf2snipe.cache')
    logging.info(f"Enabling caching for API calls for {cache_time} seconds.")
    install_cache(cache_location, backend='sqlite', expire_after=cache_time)


# Use Basic Auth to request a Jamf Token.
def request_jamf_token():
    # Tokens expire after 30 minutes (new API)
    global CONFIG, JAMF_HEADERS, JAMF_EXPIRES

    api_url = f"{CONFIG['jamf']['url']}/api/v1/auth/token"

    # We assume it may take ~15 seconds to get a token
    if ('Authorization' in JAMF_HEADERS and JAMF_HEADERS['Authorization'] and
            JAMF_EXPIRES > datetime.now() + timedelta(seconds=15)):
        api_url = f"{CONFIG['jamf']['url']}/api/v1/auth/keep-alive"

    # No hook for this api call.
    logging.debug(f'Calling for a token against: {api_url}')

    response = api_call(api_url,
                        auth=(CONFIG['jamf']['username'], CONFIG['jamf']['password']),
                        method="POST",
                        headers=JAMF_HEADERS)

    response_json = response.json()
    # No hook for this API call.
    if response.status_code == 200:
        logging.debug("Got back a valid 200 response code.")
        # DEV: Only enable this if you want to see the token in the log.
        # logging.debug(jsonresponse)
        try:
            # Parse this 2022-01-24T21:35:20.373Z or  2023-10-12T00:09:38Z
            if "." in response_json['expires']:
                JAMF_EXPIRES = datetime.strptime(response_json['expires'], "%Y-%m-%dT%H:%M:%S.%fZ")
            else:
                JAMF_EXPIRES = datetime.strptime(response_json['expires'], "%Y-%m-%dT%H:%M:%SZ")
        except ValueError:
            logging.error(f"Timestamp in {response_json} is invalid - exiting")
            raise SystemExit("Unable to grok Jamf Timestamp - Exiting")

        logging.debug(f"Token expires at {JAMF_EXPIRES}")

        # The headers are also global, because they get used elsewhere.
        logging.info("Setting new jamf headers with bearer token")
        JAMF_HEADERS['Authorization'] = f'Bearer {response_json["token"]}'
    else:
        logging.error("Could not obtain a token for use, please check your username and password.")
        raise SystemExit("Unable to obtain Jamf Token")


# Function to make the API call for all JAMF devices
# Returns a list of all computers in JAMF with inventory details
# Pass filter_rsql in rsql format - e.g. "general.assetTag==123456"
@lru_cache(maxsize=64)
def get_jamf_computers(filter_rsql=None):
    global CONFIG
    # Sections the user wants to retrieve, we require general and hardware for getting serial/asset numbers
    sections = {"GENERAL", "HARDWARE", "PURCHASING"}
    for mapping in CONFIG['computers-api-mapping'].values():
        # Get index in JAMF_SUBSETS_COMPUTERS
        root = mapping.split(" ")[0]
        if root in JAMF_SUBSETS_COMPUTERS:
            sections.add(JAMF_SUBSETS_COMPUTERS[root])

    # Get the user mapping
    if USER_ARGS.users or USER_ARGS.users_force:
        key = CONFIG['user-mapping']['computer_api_field'].split(" ")[0]
        sections.add(JAMF_SUBSETS_COMPUTERS[key])

    search_query = "?section=" + "&section=".join(sections)

    if filter_rsql:
        search_query += f"&filter={filter_rsql}"

    logging.info("Fetching JAMF computers...")
    return get_jamf_paginated_objects(f"/api/v1/computers-inventory{search_query}")


# Function to make an API call with pagination, returning all objects
def get_jamf_paginated_objects(api, page=0):
    # Function arguments should not be mutable
    page_size = 500

    page_add = f"&page={page}&page-size={page_size}"
    response = jamf_api_call(f"{api}{page_add}", method="GET")

    if "results" not in response or not response['results'] or "totalCount" not in response:
        logging.info("Received an invalid response from Jamf, exiting")
        logging.debug(response)
        raise SystemExit("Invalid response from Jamf")

    current = response['results']
    logging.debug(f"Received: {len(current)} objects")

    page += 1
    if (page_size * page) < response['totalCount']:
        current.extend(get_jamf_paginated_objects(api, page))

    return current


# Function to make the API call for all JAMF mobile devices
@lru_cache(maxsize=64)
def get_jamf_mobiles(filter_rsql=None):
    global USER_ARGS
    # Sections the user wants to retrieve, we require general and hardware for getting serial/asset numbers
    sections = {"GENERAL", "HARDWARE"}

    for mapping in CONFIG['mobile_devices-api-mapping'].values():
        # Get index in JAMF_SUBSETS_MOBILE
        root = mapping.split(" ")[0]
        if root in JAMF_SUBSETS_MOBILE:
            sections.add(JAMF_SUBSETS_MOBILE[root])

    # Get the user mapping
    if USER_ARGS.users or USER_ARGS.users_force:
        key = CONFIG['user-mapping']['mobile_api_field'].split(" ")[0]
        sections.add(JAMF_SUBSETS_COMPUTERS[key])

    search_query = "?section=" + "&section=".join(sections)

    if filter_rsql:
        search_query += f"&filter={filter_rsql}"

    logging.info("Fetching JAMF computers...")
    return get_jamf_paginated_objects(f"/api/v2/mobile-devices/detail{search_query}")


# Function to update the asset tag of mobile devices in JAMF with a number passed from Snipe.
def update_jamf_mobiledevice_asset_tag(jamf_id, asset_tag):
    # /api/v1/computers-inventory-detail/5
    if USER_ARGS.do_not_update_jamf:
        logging.debug("Not updating JAMF as requested")
        return None

    return jamf_api_call(f"/api/v2/mobile-devices/{jamf_id}",
                         payload={"assetTag": str(asset_tag)},
                         method="PATCH")


def update_jamf_computer_asset_tag(jamf_id, asset_tag):
    if USER_ARGS.do_not_update_jamf:
        logging.debug("Not updating JAMF as requested")
        return None

    # /api/v1/computers-inventory-detail/5
    return jamf_api_call(f"/api/v1/computers-inventory-detail/{jamf_id}",
                         payload={"general": {"assetTag": str(asset_tag)}},
                         method="PATCH")


def validate_mac(mac_address: str | None) -> str | None:
    if not mac_address:
        return None

    # Remove everything that is not a hex character
    mac_address = ''.join(c for c in mac_address.upper() if c in '0123456789ABCDEF')
    # Invalid MAC
    if not mac_address or len(mac_address) != 12:
        return None

    # Random MAC addresses x2, x6, xA, xE are reserved for local use
    # This catches Microsoft Loopback, VirtualBox, GlobalProtect and Apple Private addresses
    if mac_address[1] in ['2', '6', 'A', 'E']:
        return None

    # Make it into a format understandable by Snipe-IT
    mac_address = ':'.join(mac_address[i:i + 2] for i in range(0, 12, 2))

    return mac_address


# Function to find snipe assets by serial number.
def get_snipe_asset(serial="", name="", mac_addresses=None, asset_tag=None) -> dict:
    # Asset tags always return 1 result
    if asset_tag:
        if asset_tag in CACHE["ASSET_TAG"]:
            return {'rows': [CACHE["ASSET_TAG"][asset_tag]], 'total': 1}

        api_url = f'hardware/bytag/{asset_tag}'
        response = snipe_api_call(api_url)
        if 'id' in response:
            CACHE["ASSET_TAG"][asset_tag] = response
            return {'rows': [response], 'total': 1}

    found = []
    # If we have a valid serial number use that to uniquely identify the asset
    if serial:
        found = cache_snipe_search(serial, "SERIAL")

    if mac_addresses:
        # MAC addresses *should* be unique
        for mac_address in mac_addresses:
            if found:
                break
            found = cache_snipe_search(mac_address, "MAC")

    # If we have a name, we can search for that
    if not found:
        found = cache_snipe_search(name, "NAME")

    # Make a list from the found dict
    return {'rows': found, 'total': 1}


CACHE = {"MAC": {}, "NAME": {}, "SERIAL": {}, "ASSET_TAG": {}, 'hits': 0}


def paginated_snipe_search(search, page=0):
    page_size = 500
    payload = {
        'search': search,
        'limit': page_size,
        'offset': page * page_size
    }
    logging.debug(f"Searching for {payload}")

    response = snipe_api_call("hardware", method="GET", payload=payload)

    if 'total' not in response or 'rows' not in response or not response['rows']:
        return {'rows': [], 'total': 0}

    if payload['offset'] + payload['limit'] < response['total']:
        response['rows'].extend(paginated_snipe_search(search, page + 1)['rows'])

    logging.debug(response)
    return response


def cache_snipe_search(search: str, search_type: str) -> list:
    search = search.upper()
    if search in CACHE[search_type]:
        CACHE['hits'] = CACHE['hits'] + 1
        return [CACHE[search_type][search]]

    # We search only the first 5 characters, that way we don't need to re-search for similar names
    response = paginated_snipe_search(search.upper()[0:5])

    for row in response['rows']:
        for field_name, field in row['custom_fields'].items():
            if field['field_format'] == 'MAC':
                CACHE["MAC"][field['value'].upper()] = row

        CACHE["NAME"][html.unescape(row['name']).upper()] = row
        CACHE["SERIAL"][row['serial'].upper()] = row
        CACHE["ASSET_TAG"][row['asset_tag'].upper()] = row

    if search.upper() in CACHE[search_type]:
        return [CACHE[search_type][search.upper()]]

    return []


# Helper function to call an API
def api_call(api_url, json=None, method="GET", headers=None, auth=None) -> Response:
    logging.debug(f"Calling {api_url} with method {method} and payload {json}")

    if method == "GET":
        response = requests.get(api_url, headers=headers, json=json, verify=USER_ARGS.do_not_verify_ssl)
    elif method == "POST":
        response = requests.post(api_url, auth=auth, headers=headers, json=json, verify=USER_ARGS.do_not_verify_ssl)
    elif method == "PATCH":
        response = requests.patch(api_url, headers=headers, json=json, verify=USER_ARGS.do_not_verify_ssl)
    else:
        logging.error(f"Unknown method {method}")
        raise SystemExit("Unknown method")

    return response


def snipe_api_call(endpoint, payload=None, method="GET"):
    global CONFIG, SNIPE_HEADERS, SNIPE_BACKOFF

    api_url = f"{CONFIG['snipe-it']['url']}/api/v1/{endpoint}"

    # Snipe-IT API does not understand JSON with GET requests
    if method == "GET" and payload:
        api_url += "?"
        for key, value in payload.items():
            api_url += f"{key}={value}&"
        api_url = api_url[:-1]
        payload = None

    response = api_call(api_url, payload, method, SNIPE_HEADERS)

    if response.status_code == 200:
        if SNIPE_BACKOFF:
            SNIPE_BACKOFF -= 1
        # DEV: This is a lot of output
        # logging.debug(f"Got a valid response from Snipe-IT: {response.text}")
        return response.json()

    if response.status_code == 429:
        SNIPE_BACKOFF += 1
        backoff = SNIPE_BACKOFF * 30
        logging.warning(f'Snipe-IT ratelimit exceeded: pausing {backoff}s')
        sleep(backoff)
        logging.info("Finished waiting. Retrying lookup...")
        return snipe_api_call(endpoint, payload, method)

    logging.error(f"Snipe-IT responded with error code:{response.text}")
    logging.debug(f"{response.status_code} - {response.content}")
    raise SystemExit("Snipe-IT API call failed")


def jamf_api_call(endpoint, payload=None, method="GET"):
    global CONFIG, JAMF_HEADERS, JAMF_BACKOFF, JAMF_EXPIRES
    api_url = f"{CONFIG['jamf']['url']}{endpoint}"

    if JAMF_EXPIRES < datetime.now() + timedelta(minutes=2):
        logging.info("Token expiring soon or already expired, requesting new token")
        request_jamf_token()

    response = api_call(api_url, payload, method, JAMF_HEADERS)

    if response.status_code == 200:
        return response.json()

    if response.status_code == 429:
        JAMF_BACKOFF += 1
        backoff = JAMF_BACKOFF * 30
        logging.warning(f'JAMF Pro Ratelimit exceeded: pausing {backoff}s')
        sleep(backoff)
        logging.info("Finished waiting. Retrying lookup...")
        return jamf_api_call(endpoint, payload, method)

    logging.error(f"JAMF responded with error code:{response.text}")
    logging.debug(f"{response.status_code} - {response.content}")
    raise SystemExit("JAMF API call failed")


# Function to get all the asset models (and cache them)
def get_snipe_models(page=0):
    page_size = 500
    payload = {
        'limit': page_size,
        'offset': page * page_size
    }
    models = {}
    response = snipe_api_call("models", payload=payload, method="GET")

    # This happens if there is an error
    if "total" not in response:
        logging.error("Fetching models failed, enable debug to see response")
        raise SystemExit("Necessary Snipe-IT API call failed")
    logging.debug(f"Fetching models, {payload['offset']}+{payload['limit']}/{response['total']}")

    # Quickly end if there are no rows
    if "rows" not in response:
        return models

    # Add the models to the dictionary
    for row in response['rows']:
        models[row['model_number']] = row['id']
        models[row['name']] = row['id']

    # If we haven't gotten all the models, get more
    if response['total'] > payload['limit'] + payload['offset']:
        models.update(get_snipe_models(page + 1))

    return models


# Function to search snipe for a user
@lru_cache(maxsize=None)
def get_snipe_user_id(username):
    if not username:
        return None

    payload = {"username": username.lower(), "all": True}
    response = snipe_api_call(f"users", payload=payload, method="GET")

    if 'total' not in response or response['total'] == 0:
        logging.debug(f"Got a valid response but no users")
        return None

    if response['total'] > 1:
        logging.warning(f"Got multiple responses for a username")
        return None

    return int(response['rows'][0]['id'])


# Function that creates a new Snipe Model - not an asset - with a JSON payload
def create_snipe_model(model):
    response = snipe_api_call("models", payload=model, method="POST")

    if "payload" not in response or not response['payload']:
        logging.error(f'Unable to create model: {model}. Received {response}')
        return None

    return response['payload']['id']


# Function to create a new asset by passing array
def create_snipe_asset(asset):
    logging.info(f"Creating asset in Snipe-IT")
    response = snipe_api_call("hardware", payload=asset, method="POST")
    if "payload" not in response or not response['payload']:
        logging.error(f'Unable to create asset: {asset}. Received {response}')
        raise SystemExit("Unable to create asset(s)")

    return response['payload']


# Function that updates a snipe asset with a JSON payload
def update_snipe_asset(old_asset, new_asset):
    if 'serial_number' in new_asset and old_asset['serial'] == new_asset['serial_number']:
        del new_asset['serial_number']

    if ('status_id' in new_asset and old_asset['status_label'] and
            old_asset['status_label']['id'] == new_asset['status_id']):
        del new_asset['status_id']

    if 'model_id' in new_asset and old_asset['model'] and old_asset['model']['id'] == new_asset['model_id']:
        del new_asset['model_id']

    if 'category_id' in new_asset and old_asset['category'] and old_asset['category']['id'] == new_asset['category_id']:
        del new_asset['category_id']

    if 'company_id' in new_asset and old_asset['company'] and old_asset['company']['id'] == new_asset['company_id']:
        del new_asset['company_id']

    # Clean up regular fields
    for key, value in old_asset.items():
        if key in new_asset and str(value) == str(new_asset[key]):
            del new_asset[key]

    # Clean up custom fields
    for key, value in old_asset['custom_fields'].items():
        if value['field'] not in new_asset:
            continue
        old_value_str = html.unescape(str(value['value'])).strip()
        new_value_str = str(new_asset[value['field']]).strip()

        if old_value_str == new_value_str:
            del new_asset[value['field']]
            continue
        # Sometimes versions are returned chopping off the last .0
        if new_value_str + ".0" == old_value_str or new_value_str == old_value_str + ".0":
            del new_asset[value['field']]

    if new_asset:
        response = snipe_api_call(f"hardware/{old_asset['id']}", payload=new_asset, method="PATCH")

        if "payload" not in response or not response['payload']:
            logging.error(f"Unable to update asset: {old_asset['id']}. Received {response}")
            return None

        return response['payload']

    return old_asset


# Function that checks in an asset in snipe
def checkin_snipe_asset(asset_id, asset):
    if not asset['available_actions']['checkin']:
        logging.error(f"Asset {asset['name']} is not available for checkin")
        return False

    note = {
        'note': 'checked in by script from Jamf'
    }

    response = snipe_api_call(f"hardware/{asset_id}/checkin", payload=note, method="POST")

    if "payload" not in response or not response['payload']:
        logging.error(f'Unable to checkin asset: {asset_id}. Received {response}')
        return False

    return True


# Function that checks out an asset in snipe
def checkout_snipe_asset(username, asset):
    global USER_ARGS

    if (not USER_ARGS.users and not USER_ARGS.users_force) or not username:
        return False

    logging.info(f"Asset {asset['name']} is being checked out to {username}")
    # logging.debug(asset)

    user_id = get_snipe_user_id(username)

    if not user_id:
        logging.error(f"Unable to checkout asset: {asset['name']} to user {username}, user does not exist")
        return False

    if 'assigned_to' in asset and asset['assigned_to']:
        # Sometimes my JAMF API returns an int, sometimes a dict. This makes it consistent.
        if isinstance(asset['assigned_to'], int):
            temp_user_id = asset['assigned_to']
            asset['assigned_to'] = {}
            asset['assigned_to']['id'] = temp_user_id

        if asset['assigned_to']['id'] == user_id:
            logging.info(f"Asset {asset['id']} is already checked out to {username}")
            return True

        logging.info(f"Asset {asset['id']} is already checked out to UID: {asset['assigned_to']['id']}")

        if not USER_ARGS.users_force:
            return False

        if not checkin_snipe_asset(asset['id'], asset):
            return False

    payload = {
        'checkout_to_type': 'user',
        'assigned_user': user_id,
        'note': 'Assignment made automatically, via script from Jamf.'
    }

    response = snipe_api_call(f"hardware/{asset['id']}/checkout", payload=payload, method="POST")

    if "payload" not in response or not response['payload']:
        logging.error("Asset checkout failed, enable debug to see more information")
        logging.debug(response)
        return False

    return True


# Function to recursively get keys from a dictionary
def get_config_value(config_key, data, invalid_values=None):
    logging.debug(f"Getting config value for {config_key}")
    # logging.debug(f"Data: {data}")
    split_key = config_key.split("|", 1)
    search_keys = split_key[0].strip().split(" ")
    j2_str = None
    if len(split_key) > 1:
        j2_str = split_key[1].strip()
        logging.debug(f"Jinja2 template: {j2_str}")

    value = data
    for key in search_keys:
        try:
            # Try to convert to int, settings file returns strings,
            # but if we want to traverse a list we need an int
            key = int(key)
        except ValueError:
            logging.debug(f"{key} is not an integer")
        try:
            value = value[key]
        except (KeyError, IndexError, TypeError):
            # JAMF is not consistent with return types
            logging.info(f"{key} does not exist or is empty")
            logging.debug(f"Key value: {value}")
            value = None
            break

    if invalid_values and value in invalid_values:
        value = None

    if j2_str:
        template = Template(j2_str)
        template.globals.update({'validate_mac': validate_mac, 'clean_tag': clean_tag})
        value = template.render(var=value, data=data)

    logging.debug(f"Got value {value} for {config_key}")
    return value


def clean_tag(param: str) -> str:
    # Remove illegal values
    if not param or str(param).lower() in ["unknown", "not available", "0", "n/a", "none", ""]:
        return None

    return param


YEAR_REGEXP = re.compile(r'\d{4}')


def query_apple_warranty(serial, model_name=None):
    # http://www.macrumors.com/2010/04/16/apple-tweaks-serial-number-format-with-new-macbook-pro/

    year_re = YEAR_REGEXP.search(model_name)
    if not year_re:
        logging.warning(f"No year found in model name {model_name}, skipping {serial}")
        if model_name == 'Mac Studio':
            return date(year=2022, month=3, day=18)

        return None
    year = int(year_re.group())

    if len(serial) == 11:
        # Old format
        year = serial[2].lower()
        est_year = 2000 + '   3456789012'.index(year)
        week = int(serial[3:5]) - 1
        year_time = date(year=int(est_year), month=1, day=1)
        if week:
            week_dif = timedelta(weeks=int(week))
            year_time += week_dif

        return year_time
    # Apple starts randomizing serial numbers in 2021
    elif year < 2021 and 11 < len(serial) < 16:
        # New format
        alpha_year = 'cdfghjklmnpqrstvwxyz'
        alpha_est_year = serial[3].lower()
        est_year = int(2010 + (alpha_year.index(alpha_est_year) / 2))
        # 1st or 2nd half of the year
        est_half = alpha_year.index(alpha_est_year) % 2
        week = serial[4].lower()
        alpha_week = ' 123456789cdfghjklmnpqrtvwxy'
        est_week = alpha_week.index(week) + (est_half * 26) - 1
        # If the year is off by more than 3 years, assume we're miscalculating
        if abs(year - est_year) > 3:
            est_year += 10
        year_time = date(year=est_year, month=1, day=1)
        if est_week:
            week_dif = timedelta(weeks=int(est_week))
            year_time += week_dif
        return year_time

    return date(year=year, month=1, day=1)


def main():
    global USER_ARGS
    # Get a list of known models from Snipe
    logging.info("Getting a list of computer models that snipe knows about.")
    modelnumbers = get_snipe_models()
    logging.debug(f"Our list of models has {len(modelnumbers)} entries.")
    logging.debug(f"Model list: {modelnumbers}")

    # Get a list of computers from JAMF
    mobile_filter = CONFIG['jamf'].get("mobile_devices-filter", None)
    computer_filter = CONFIG['jamf'].get("computer-filter", None)
    if USER_ARGS.computers:
        complete_list = get_jamf_computers(computer_filter)
    elif USER_ARGS.mobiles:
        complete_list = get_jamf_mobiles(mobile_filter)
    else:
        complete_list = get_jamf_computers(computer_filter)
        complete_list.extend(get_jamf_mobiles(mobile_filter))

    total = len(complete_list)

    # Make sure we have a good list.
    logging.info(f'Received a list of JAMF assets that had {total} entries.')

    # After this point we start editing data, so quit if this is a dryrun
    if USER_ARGS.dryrun:
        raise SystemExit("Dryrun: Complete.")

    # From this point on, we're editing data.
    logging.info('Starting to Update Inventory')

    for jamf_asset in complete_list:
        # We can differentiate between a computer and a mobile device by the presence of a mobileDeviceId
        logging.debug(f"Processing JAMF asset: {jamf_asset}")
        custom_fieldset_id = None

        if "mobileDeviceId" in jamf_asset:
            jamf_id = jamf_asset['mobileDeviceId']
            category_id = CONFIG['snipe-it']['mobile_model_category_id']
            api_mapping = CONFIG['mobile_devices-api-mapping']
            jamf_username = get_config_value(CONFIG['user-mapping']['mobile_api_field'],
                                             jamf_asset,
                                             CONFIG['user-mapping'].get('invalid_users', "").split(" "))
            if 'computer_custom_fieldset_id' in CONFIG['snipe-it']:
                custom_fieldset_id = int(CONFIG['snipe-it']['computer_custom_fieldset_id'])
            asset_tag_prefix = CONFIG['snipe-it'].get('mobile_asset_tag_prefix', 'jamfid-m-')
            if ('lastInventoryUpdateDate' not in jamf_asset['general'] or
                    not jamf_asset['general']['lastInventoryUpdateDate']):
                logging.warning(f"Asset {jamf_id} has no last inventory update date")
                jamf_update_time = datetime.fromtimestamp(0)
            elif "." in jamf_asset['general']['lastInventoryUpdateDate']:
                jamf_update_time = datetime.strptime(jamf_asset['general']['lastInventoryUpdateDate'],
                                                     "%Y-%m-%dT%H:%M:%S.%fZ")
            else:
                jamf_update_time = datetime.strptime(jamf_asset['general']['lastInventoryUpdateDate'],
                                                     "%Y-%m-%dT%H:%M:%SZ")
        else:
            jamf_id = jamf_asset['id']
            category_id = CONFIG['snipe-it']['computer_model_category_id']
            api_mapping = CONFIG['computers-api-mapping']
            jamf_username = get_config_value(CONFIG['user-mapping']['mobile_api_field'],
                                             jamf_asset,
                                             CONFIG['user-mapping'].get('invalid_users', "").split(" "))
            if 'computer_custom_fieldset_id' in CONFIG['snipe-it']:
                custom_fieldset_id = int(CONFIG['snipe-it']['computer_custom_fieldset_id'])
            asset_tag_prefix = CONFIG['snipe-it'].get('computer_asset_tag_prefix', 'jamfid-')
            if 'reportDate' not in jamf_asset['general'] or not jamf_asset['general']['reportDate']:
                logging.warning(f"Asset {jamf_id} has no report date")
                jamf_update_time = datetime.fromtimestamp(0)
            elif "." in jamf_asset['general']['reportDate']:
                jamf_update_time = datetime.strptime(jamf_asset['general']['reportDate'], "%Y-%m-%dT%H:%M:%S.%fZ")
            else:
                jamf_update_time = datetime.strptime(jamf_asset['general']['reportDate'], "%Y-%m-%dT%H:%M:%SZ")

        logging.debug(f"Processing JAMF ID: {jamf_id}")

        model_jamf_id = jamf_asset['hardware']['modelIdentifier']
        model_jamf_name = jamf_asset['hardware']['model']
        serial_number = clean_tag(get_config_value(api_mapping['serial_number'], jamf_asset))

        if not serial_number:
            logging.warning(f"Asset {jamf_id} has no (valid) serial number, skipping")
            continue

        asset_tag = clean_tag(get_config_value(api_mapping['asset_tag'], jamf_asset))
        if not asset_tag:
            asset_tag = f"{asset_tag_prefix}{jamf_id}"

        name = clean_tag(get_config_value(api_mapping['name'], jamf_asset))
        if not name:
            logging.error(f"Asset {jamf_id} has no name associated with it, skipping")
            continue

        if model_jamf_id and model_jamf_id not in modelnumbers:
            logging.warning(f"Asset {jamf_id} has an unknown model {model_jamf_id}")
            model = {
                "manufacturer_id": CONFIG['snipe-it']['manufacturer_id'],
                "name": model_jamf_name,
                "model_number": model_jamf_id,
                "category_id": category_id,
                "eol": CONFIG['snipe-it'].get('default_eol', 84)
            }
            if custom_fieldset_id:
                model['fieldset_id'] = int(CONFIG['snipe-it']['computer_custom_fieldset_id'])

            modelnumbers[model_jamf_id] = create_snipe_model(model)

        asset = {
            'name': name,
            'serial_number': serial_number,
            'asset_tag': asset_tag,
            'model_id': modelnumbers[model_jamf_id],
            'status_id': int(CONFIG['snipe-it']['default_status_id'])
        }

        # Get MAC addresses
        raw_macs = []
        if 'wifiMacAddress' in jamf_asset['hardware']:
            raw_macs.append(jamf_asset['hardware']['wifiMacAddress'])
        if 'bluetoothMacAddress' in jamf_asset['hardware']:
            raw_macs.append(jamf_asset['hardware']['bluetoothMacAddress'])
        if 'macAddress' in jamf_asset['hardware']:
            raw_macs.append(jamf_asset['hardware']['macAddress'])
        if 'altMacAddress' in jamf_asset['hardware']:
            raw_macs.append(jamf_asset['hardware']['altMacAddress'])

        mac_addresses = []
        for mac_address in raw_macs:
            if not validate_mac(mac_address):
                continue
            mac_addresses.append(mac_address)

        # Get the asset from snipe
        snipe_assets = get_snipe_asset(serial=serial_number,
                                       name=name,
                                       mac_addresses=mac_addresses,
                                       asset_tag=asset_tag)

        if snipe_assets['total'] > 1:
            logging.warning(f"Found {len(snipe_assets)} assets with serial {serial_number}, skipping")
            continue

        for api_key in api_mapping:
            if api_key in ['serial_number', 'asset_tag', 'name']:
                continue
            value = clean_tag(get_config_value(api_mapping[api_key], jamf_asset))
            if value:
                asset[api_key] = value

        if not snipe_assets or snipe_assets['total'] == 0:
            # Create a new asset
            logging.info(f"Creating a new asset in snipe for JAMF ID: {jamf_id}")
            asset = parse_purchasing(asset, jamf_asset, model_jamf_name, serial_number)
            snipe_asset = create_snipe_asset(asset)
        else:
            logging.info(f"Asset exists in snipe for JAMF ID: {jamf_id}")
            snipe_asset = snipe_assets['rows'][0]
            logging.debug(snipe_asset)
            # Snipe formats 2023-10-11 11:43:34
            snipe_update_time = datetime.strptime(snipe_asset['updated_at']['datetime'], "%Y-%m-%d %H:%M:%S")
            if asset_tag.startswith(asset_tag_prefix):
                del asset['asset_tag']

            if not snipe_asset['warranty_months'] or not snipe_asset['purchase_date']:
                asset = parse_purchasing(asset, jamf_asset, model_jamf_name, serial_number)

            # Check if we need updating
            if USER_ARGS.force or snipe_update_time < jamf_update_time:
                snipe_asset = update_snipe_asset(snipe_asset, asset)

        # Checking out
        # Username could be in assigned_to
        checkout_snipe_asset(jamf_username, snipe_asset)

        if str(snipe_asset['asset_tag']) != str(jamf_asset['general']['assetTag']):
            logging.info(f"Updating JAMF asset tag from {jamf_asset['general']['assetTag']} to {asset_tag}")
            if "mobileDeviceId" in jamf_asset:
                update_jamf_mobiledevice_asset_tag(jamf_id, asset_tag)
            else:
                update_jamf_computer_asset_tag(jamf_id, asset_tag)

    logging.info(f"Cache hits: {CACHE['hits']}\n"
                 f"Cache size:\n"
                 f"{len(CACHE['MAC'])} MACs\n"
                 f"{len(CACHE['NAME'])} names\n"
                 f"{len(CACHE['SERIAL'])} serials\n"
                 f"{len(CACHE['ASSET_TAG'])} asset tags\n")


def parse_purchasing(update_dict, jamf_asset, model_jamf_name, serial_number):
    if 'purchasing' in jamf_asset and jamf_asset['purchasing']:
        purchase_cost = jamf_asset['purchasing'].get('purchasePrice', 0)
        if purchase_cost:
            update_dict['purchase_cost'] = purchase_cost
        lease_date = jamf_asset['purchasing'].get('leaseDate', None)
        purchase_date = jamf_asset['purchasing'].get('poDate', lease_date)
        if purchase_date:
            update_dict['purchase_date'] = purchase_date
            warranty_ends = jamf_asset['purchasing'].get('warrantyDate', None)
            if warranty_ends:
                update_dict['warranty_months'] = (datetime.strptime(warranty_ends, "%Y-%m-%d") - datetime.strptime(
                    purchase_date, "%Y-%m-%d")).days // 30
        else:
            logging.debug(f"Asset has no purchase date, making a guess")
            purchase_date = query_apple_warranty(serial_number, model_jamf_name)
            if purchase_date:
                update_dict['purchase_date'] = purchase_date.strftime("%Y-%m-%d")
                update_dict['warranty_months'] = 36

    return update_dict


if __name__ == "__main__":
    main()
